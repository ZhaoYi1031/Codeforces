# Codeforces Round #466

[传送门](http://codeforces.com/contest/940)

一次比较简单的CF。前四题比较easy且没坑，主要说一下E题。当时现场做的时候dp想的有点不清楚导致有个漏了语句`f[i] = max(f[i-1], f[i]);`而与AC失之交臂。主要分析一下这么E题吧。

## E. Cashback

题目大意比较简单，给你一个序列和m，要你对这个序列进行划分，对于每个划分，如果长度为L，那么这个子序列的和就是去掉[L/m]最小值的和。最后要求一个划分，使得和要最小。

首先，我们可以很直观的根据几个例子推出这样的规律，尽量要划分。因为m=2，序列为[1,2,100,200]如果不划分的最小值是100+200=300，划分成两个的最小值是1+100=101。还有一种分法就是1个数单独的一段。比如长度是m+p(0<p<m)的数组，那么最优的效果肯定是一个长度为m和p个长度为1的。所以，在最优方案里，子数组的长度要么是1，要么是m。

我是用树状数组求[i-m+1,i]的最小值的，当然也可以用RMQ、线段树。另外，由于该题的特殊性，用multiset更简单，代码如下：

```multiset<ll> v;
rep (i, 1, n){
   cin >> a[i];
   sum+=a[i];
   if (i > m){
       sum-=a[i-m];
       v.erase(v.find(a[i-m]));
   }
   v.insert(a[i]);
   f[i] = f[i-1]+a[i]; //单独一人一块
   if (i >= m)
       f[i] = min(f[i], f[i-m]+sum - *v.begin());//前m个分块
}      
```

